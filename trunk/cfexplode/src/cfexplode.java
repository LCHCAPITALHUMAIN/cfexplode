/* $Id$ */
package com.veracode.research;

import java.util.*;
import java.util.zip.*;
import java.util.jar.*;
import java.io.*;
//import org.apache.bcel.classfile.*;

/*
 * cfexplode:  
 *     transform files containing one or more concatenated classfiles into a series of
 *     files with a common prefix.  particularly useful on classes generated by coldfusion's
 *     compiler.  
 *
 *     when passed zip/war/ear/jar files, every classfile inside will be processed.  
 *     where possible, the directory hierarchy in the destination directory mirrors the
 *     directory structure inside the archive.  
 *
 * Usage:
 *     the first argument is the base output directory; remaining arguments are classfiles
 *     or archives to process.
 *
 *     the output files will be named foo.0.class, foo.3242.class, etc. for an output file 
 *     named "foo" (pathname included), unless such a file exists already.  the numbers in
 *     the file represent the offset in the original file of the start of the class data.
 *     if a file with that name exists already, then a timestamp+random nonce-based filename 
 *     will be used instead. 
 *     
 *  Known bugs:
 *         - inner zip files larger than 2GB may cause problems (ZipInputStream.read())
 *
 *     Abbreviated history:
 *         - 20090826 bcreighton@veracode.com: initial 
 *         - 20090827 bcreighton@veracode.com: create destination directory hierarchy 
 *                    when necessary
 *         - 20100803 bcreighton@veracode.com: remove dependency on bcel (except for
 *                    comparison purposes); initial release
 */

public class cfexplode {
    public final int CONSTANT_Class = 7,
        CONSTANT_Fieldref = 9,
        CONSTANT_Methodref = 10,
        CONSTANT_InterfaceMethodref = 11,
        CONSTANT_String = 8,
        CONSTANT_Integer = 3,
        CONSTANT_Float = 4,
        CONSTANT_Long = 5,
        CONSTANT_Double = 6,
        CONSTANT_NameAndType = 12,
        CONSTANT_Utf8 = 1;
    private File outputdir;
    private String pathSep;

    public static void main(String[] args) {
        if(args.length < 2) {
            System.err.println("cfexplode: $Id$");
            System.err.println("args: outputdir class1 [class2 .. classN]");
            System.exit(1);
        }
        List<File> jars = new ArrayList<File>(), classes = new ArrayList<File>();
        File outdir = new File(args[0]);
        for(int i = 1; i < args.length; i++) {
            try {
                File f = new File(args[i]);
                if(!f.exists()) {
                    warn("file not found: " + f.getPath());
                    continue;
                }
                FileInputStream fis = null;
                try {
                    byte[] magic = new byte[4];
                    fis = new FileInputStream(f);
                    if(fis.read(magic) < 4) {
                        warn("unknown file type (couldn't read first 4 bytes for magic): " 
                                + f.getPath());
                    }
                    // zip magic: PK\003\004
                    if(isZip(magic)) {
                        jars.add(f);
                    } else if(isClassfile(magic)) {
                        classes.add(f);
                    } else {
                        warn("not a classfile or zip/jar/war/ear file: " + f.getPath());
                    }

                    cfexplode cfe = new cfexplode(outdir);
                    for(File jar: jars) {
                        cfe.handleJar(jar);
                    }
                    for(File classf: classes) {
                        cfe.handleConcatenated(classf);
                    }
                } catch (Exception ex) {
                    warn("unable to open and read from file " + f.getPath() + ": " 
                            + ex.getMessage());
                } finally {
                    if(fis != null) {
                        try {
                            fis.close();
                        } catch(Exception ignore) { }
                    }
                }
                //cfexplode cfe = new cfexplode(args[0], args[i]);
                //cfe.dump();
            } catch (Throwable t) {
                System.out.println("caught exception while parsing file " + args[i]);
                t.printStackTrace();
                System.exit(1);
            }
        }
        System.exit(0);
    }

    public cfexplode(File outputdir) {
        this.outputdir = outputdir;
        this.pathSep = System.getProperty("file.separator");
    }

    public void handleJar(File jarfile) {
        FileInputStream fis = null;
        ZipInputStream zis = null;
        try {
            fis = new FileInputStream(jarfile);
            zis = new ZipInputStream(fis);
            handleZipStream(jarfile.getName(), zis);
        } catch (Exception ex) {
            if(fis != null) {
                try {
                    fis.close(); 
                } catch (Throwable ignore) { }
            }
            if(zis != null) {
                try {
                    zis.close();
                } catch (Throwable ignore) { }
            }
            error("error while parsing zip file: " + jarfile.getPath(), ex);
            return;
        }
    }
    public static byte[] readEntry(byte[] start, ZipInputStream zis) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(start);
        int retval = 0;
        byte[] buf = new byte[65536];
        while(true) {
            retval = zis.read(buf, 0, buf.length);
            if(retval == -1) {
                break;
            }
            baos.write(buf, 0, retval);
        }
        buf = baos.toByteArray();
        baos.close();
        return buf;
    }
    public void handleZipStream(String jarfilename, ZipInputStream zis) throws Exception {
        ZipEntry entry;
        while((entry = zis.getNextEntry()) != null) {
            if(entry.isDirectory()) {
                continue;
            }
            long size = entry.getSize();
            if(size == -1) {
                // This is normal on inner jars.  Do nothing.
            } else if(size < 4) {
                continue;
            }
            byte[] magic = new byte[4];
            int retval;
            if((retval = zis.read(magic, 0, 4)) != 4) {
                warn("unable to read magic for entry " + entry.getName() + " of zip " 
                        + jarfilename + ": " + retval);
                continue;
            }
            if(isZip(magic)) {
                byte[] buf = readEntry(magic, zis);
                ByteArrayInputStream bais = new ByteArrayInputStream(buf);
                ZipInputStream innerzis = null;
                try {
                    innerzis = new ZipInputStream(bais);
                    handleZipStream(jarfilename + pathSep + entry.getName(), innerzis);
                } catch (Exception ex) {
                    error("exception while parsing zip " + jarfilename + pathSep 
                            + entry.getName(), ex);
                } finally {
                    innerzis.close();
                    bais.close();
                }
            } else if(isClassfile(magic)) {
                byte[] buf = readEntry(magic, zis);
                try {
                    handleConcatBuf(jarfilename + pathSep + entry.getName(), buf);
                 } catch (Exception ex) {
                    error("exception while parsing concatenated class " + jarfilename + pathSep 
                            + entry.getName(), ex);
                }
            }
        }
    }
    // If this is the start of a valid classfile, parse the entire classfile structure and
    // return the number of bytes that comprise the class.  
    // 
    // If this isn't a valid classfile (e.g. a Mach-O fat binary; these also start with
    // 0xCAFEBABE), return -1.
    public long calcClassLength(InputStream is) throws IOException {
        DataInputStream dis = new DataInputStream(is);
        int i1;
        long count = 0;
        if((i1 = dis.readInt()) != 0xcafebabe) {
            throw new IOException("file changed!  magic no longer valid: " + i1);
        }
        int minor = dis.readUnsignedShort();
        int major = dis.readUnsignedShort();
        if(major < 40) {
            return -1;
        }
        int constants = dis.readUnsignedShort();
        count = 10;
        for(int i = 1; i < constants; i++) {
            int tag = dis.readUnsignedByte();
            //System.out.println("XXX const: " + i + "/" + constants + ": " + tag);
            count++;
            switch(tag) {
                case CONSTANT_Class:
                case CONSTANT_String:
                    dis.readUnsignedShort();
                    count += 2;
                    break;
                case CONSTANT_Fieldref:
                case CONSTANT_Methodref:
                case CONSTANT_InterfaceMethodref:
                case CONSTANT_NameAndType:
                    dis.readUnsignedShort();
                    dis.readUnsignedShort();
                    count += 4;
                    break;
                case CONSTANT_Integer:
                    dis.readInt();
                    count += 4;
                    break;
                case CONSTANT_Float:
                    dis.readFloat();
                    count += 4;
                    break;
                case CONSTANT_Long:
                case CONSTANT_Double:
                    i++;
                    dis.readInt();
                    dis.readInt();
                    count += 8;
                    break;
                case CONSTANT_Utf8:
                    int len = dis.readUnsignedShort();
                    //System.out.println("XXX utf8 count " + count + " const len: " + len);
                    byte[] buf = new byte[len];
                    dis.readFully(buf);
                    count += (2 + len);
                    break;
                default:
                    System.out.println("XXX unknown tag!: " + tag);
                    break;
            }
        }
        dis.readUnsignedShort();    // access_flags
        dis.readUnsignedShort();    // this_class
        dis.readUnsignedShort();    // super_class
        int interfaces = dis.readUnsignedShort();    // interfaces_count
        //System.out.println("XXX interfaces: " + interfaces);
        count += 8;
        if(interfaces > 0) {
            byte[] buf = new byte[2 * interfaces];
            dis.readFully(buf);
            count += (2 * interfaces);
        }
        int fields = dis.readUnsignedShort();   // fields_count;
        //System.out.println("XXX fields: " + fields);
        count += 2;
        for(int i = 0; i < fields; i++) {
            dis.readUnsignedShort();    // access_flags
            dis.readUnsignedShort();    // name_index
            dis.readUnsignedShort();    // descriptor_index
            int attrcount = dis.readUnsignedShort();    // attributes_count
            //System.out.println("XXX field " + i + "/" + fields + " attributes_count: " + attrcount);
            count += 8;
            for(int j = 0; j < attrcount; j++) {
                count += read_attribute(dis);
            }
        }
        int methods = dis.readUnsignedShort();  // methods_count
        //System.out.println("XXX methods: " + methods);
        count += 2;
        for(int i = 0; i < methods; i++) {
            dis.readUnsignedShort();    // access_flags
            dis.readUnsignedShort();    // name_index
            dis.readUnsignedShort();    // descriptor_index
            int attrcount = dis.readUnsignedShort();    // attributes_count
            count += 8;
            for(int j = 0; j < attrcount; j++) {
                count += read_attribute(dis);
            }
        }
        int attributes = dis.readUnsignedShort();   // attributes_count
        //System.out.println("XXX attributes: " + attributes);
        count += 2;
        for(int i = 0; i < attributes; i++) {
            count += read_attribute(dis);
        }
        return count;
    }
    public long read_attribute(DataInputStream dis) throws IOException, EOFException {
        dis.readUnsignedShort();        // attribute_name_index
        int attrlen = dis.readInt();        // attribute_length
        //System.out.println("    attrlen " + attrlen);
        if(attrlen < 0) {
            throw new IOException("bad attribute_length!: " + attrlen);
        }
        byte[] buf = new byte[attrlen];
        dis.readFully(buf);
        return 6+attrlen;
    }
    public void handleConcatBuf(String filename, byte[] buf) throws Exception {
        long curpos = 0;
        ArrayList<String> filenames = new ArrayList<String>();
        FileOutputStream fos = null;
        try {
            while(curpos < buf.length) {
                //System.out.println("---- XXX new file: curpos " + curpos);
                ByteArrayInputStream bais = new ByteArrayInputStream(buf);
                bais.skip(curpos);
                long len = calcClassLength(bais);
                try {
                    bais.close();
                } catch (Exception ignore) { }
                if(len == -1) {
                    break;
                }
                bais = new ByteArrayInputStream(buf);
                bais.skip(curpos);

                //ClassParser cp = new ClassParser(bais, filename);
                //JavaClass cl = cp.parse();
                //byte[] classdata = cl.getBytes();
                //if(classdata.length != len) {
                //    warn("XXX: BCEL misjudged; file " + filename + " calculated " + len 
                //            + "  BCEL calculated " + classdata.length);
                //}
                //
                File nf = getNewFile(filename, curpos);
                fos = new FileOutputStream(nf, false);
                byte[] iobuf = new byte[40960];
                for(long l = 0; l < len; l++) {
                    int toread = (int)(len > iobuf.length ? iobuf.length : len);
                    bais.read(iobuf, 0, toread);
                    fos.write(iobuf, 0, toread);
                    l += toread;
                }
                //fos.write(buf, (int)curpos, (int)len);
                //fos.write(classdata);
                fos.close();
                fos = null;
                bais.close();
                curpos += len;
            }
        } catch (Exception ex) {
            System.out.println("XXX: caught at " + filename + " curpos " + curpos);
            ex.printStackTrace();
            throw ex;
        } finally {
            if(fos != null) {
                try {
                    fos.close();
                } catch (Throwable ignore) { }
            }
        }
    }
    public void handleConcatenated(File f) throws Exception {
        FileInputStream fis = new FileInputStream(f);
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int retval = 0;
            byte[] buf = new byte[65536];
            while(true) {
                retval = fis.read(buf, 0, buf.length);
                if(retval == -1) {
                    break;
                }
                baos.write(buf, 0, retval);
            }
            buf = baos.toByteArray();

            handleConcatBuf(f.getName(), buf);
        } finally {
            if(fis != null) {
                try {
                    fis.close();
                } catch (Throwable ignore) { } 
            }
        }
    }

    public static void debug(String message) {
        System.out.println(message);
    }
    public static void warn(String message) {
        System.err.println(message);
    }
    public static void error(String message, Throwable t) {
        System.err.println(message + ": " + t.getMessage());
    }
    private File getNewFile(String filename, long pos) throws Exception {
        File f = new File(outputdir, filename + "." + pos + ".class");
        f.getParentFile().mkdirs();
        if(f.createNewFile()) {
            return f;
        }
        for(int i = 0; i < 100; i++) { 
            f = new File(outputdir, filename + "." + pos + "." + System.currentTimeMillis() + "." + new Random().nextInt() + ".class");
            f.getParentFile().mkdirs();
            if(f.createNewFile()) {
                return f;
            }
        }
        throw new Exception("couldn't find an unused filename based on original filename " + filename + " offset " + pos + " in directory " + outputdir);
    }

    public static boolean isZip(byte[] magic) {
        return (magic[0] == 0x50 && magic[1] == 0x4b && magic[2] == 3 && magic[3] == 4);
    }
    public static boolean isClassfile(byte[] magic) {
        return (magic[0] == (byte)0xca && magic[1] == (byte)0xfe 
                && magic[2] == (byte)0xba && magic[3] == (byte)0xbe);
    }
}
